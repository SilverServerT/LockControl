<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magnetic Lock Control</title>
    <link rel="icon" href="/local/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <style>
        :root {
            --primary: #1976d2;
            --primary-dark: #1565c0;
            --accent: #388e3c;
            --danger: #d32f2f;
            --bg: #f0f2f5;
            --card-bg: #fff;
            --shadow: 0 4px 24px rgba(0,0,0,0.08);
            --radius: 18px;
            --transition: 0.2s cubic-bezier(.4,0,.2,1);
            --locked: #388e3c;    /* Green for locked (safe) */
            --unlocked: #d32f2f;  /* Red for unlocked (unsafe) */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background: var(--bg);
            font-family: 'Roboto', sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            overscroll-behavior: none;
            overflow-y: auto;
        }

        .container {
            max-width: 420px;
            margin: 0 auto;
            background: var(--card-bg);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
            transition: border-color 0.3s;
            border: 4px solid #bbb;
            overflow-y: auto;
            width: 100%;
        }

        .container.locked {
            border-color: var(--locked);
        }

        .container.unlocked {
            border-color: var(--unlocked);
        }

        .container.unknown {
            border-color: #bbb;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .header h1 {
            font-size: 1.8em;
            color: var(--primary);
            margin: 0;
            font-weight: 500;
            text-align: center;
        }

        .info-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin: 20px 0;
            background: rgba(0,0,0,0.03);
            padding: 15px;
            border-radius: var(--radius);
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
            color: #666;
        }

        .info-item .material-icons {
            font-size: 1.2em;
            color: var(--primary);
        }

        .daily-code {
            width: 100%;
            background: rgba(0,0,0,0.03);
            padding: 15px;
            border-radius: var(--radius);
            margin-bottom: 20px;
            box-sizing: border-box;
        }

        .daily-code-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .daily-code-header .material-icons {
            color: var(--primary);
        }

        .daily-code-header span {
            font-weight: 500;
            color: var(--primary);
            text-align: center;
        }

        .code-display {
            font-family: monospace;
            font-size: 1.5em;
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 8px;
            margin: 5px 0;
        }

        .code-expiry {
            text-align: center;
            color: #666;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .lock-status {
            width: 100%;
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: rgba(0,0,0,0.03);
            border-radius: var(--radius);
            border: 3px solid var(--unlocked);
            transition: border-color var(--transition);
        }

        .lock-status.locked {
            border-color: var(--locked);
        }

        .lock-status-text {
            font-size: 1.2em;
            font-weight: 500;
            margin-bottom: 10px;
            color: var(--unlocked);
            transition: color var(--transition);
        }

        .lock-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 24px;
            font-size: 1em;
            border: none;
            border-radius: 10px;
            background: var(--unlocked);
            color: #fff;
            cursor: pointer;
            transition: all var(--transition);
            font-weight: 500;
            gap: 8px;
            width: 100%;
            box-sizing: border-box;
        }

        .lock-button .material-icons {
            font-size: 1.2em;
        }

        .lock-button:active {
            transform: scale(0.98);
        }

        .lock-button.locked {
            background: var(--locked);
        }

        @media (max-width: 600px) {
            .container {
                max-width: 100%;
                margin: 0;
                padding: 15px;
                min-height: auto;
                height: auto;
                overflow-y: visible;
                width: 100%;
                box-sizing: border-box;
            }

            .header h1 {
                font-size: 1.5em;
            }

            .info-bar {
                flex-wrap: wrap;
                gap: 10px;
                padding: 12px;
                width: 100%;
                box-sizing: border-box;
            }

            .info-item {
                flex: 1;
                min-width: 45%;
                justify-content: center;
            }

            .daily-code {
                width: 100%;
                box-sizing: border-box;
            }

            .lock-button {
                width: 100%;
                box-sizing: border-box;
            }

            .duration-buttons {
                width: 100%;
                box-sizing: border-box;
            }

            .duration-buttons .lock-button {
                flex: 1;
                min-width: 0;
                max-width: none;
                padding: 10px;
                font-size: 0.9em;
                background: var(--unlocked);
            }
        }

        .duration-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            box-sizing: border-box;
        }

        .duration-buttons .lock-button {
            flex: 1;
            min-width: 0;
            max-width: none;
            padding: 10px;
            font-size: 0.9em;
            background: var(--unlocked);
        }

        .success-message, .error-message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: var(--radius);
            color: white;
            font-weight: 500;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
            box-shadow: var(--shadow);
        }

        .success-message {
            background: var(--accent);
        }

        .error-message {
            background: var(--danger);
        }

        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }

        #weatherInfo {
            text-align: left;
            line-height: 1.4;
        }

        @media (max-width: 600px) {
            .info-item {
                min-height: 60px;
            }
        }

        .friesland-card {
            width: 100%;
            background: rgba(0,0,0,0.03);
            padding: 15px;
            border-radius: var(--radius);
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .friesland-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 10px;
            width: 100%;
        }

        .friesland-header .material-icons {
            color: var(--primary);
        }

        .friesland-header span {
            font-weight: 500;
            color: var(--primary);
        }

        #brandweerNotifications, #openerHistory {
            width: 100%;
            max-width: 320px;
            margin: 0 auto;
        }

        .brandweer-entry {
            display: flex;
            align-items: flex-start;
            margin: 4px 0;
            padding: 6px;
            background: rgba(0,0,0,0.03);
            border-radius: 8px;
            font-size: 0.8em;
            width: 100%;
        }

        .brandweer-entry .material-icons {
            font-size: 1.1em;
            margin-right: 6px;
            color: #d32f2f;
        }

        .brandweer-content {
            flex: 1;
        }

        .brandweer-time {
            font-size: 0.75em;
            color: #888;
            margin-top: 2px;
        }

        @media (max-width: 600px) {
            .brandweer-entry {
                font-size: 0.75em;
                padding: 4px;
                margin: 2px 0;
            }
            .brandweer-time {
                font-size: 0.7em;
            }
        }

        .lock-icon-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 10px 0;
            padding: 20px;
            background: rgba(0,0,0,0.03);
            border-radius: 50%;
            width: 120px;
            height: 120px;
            justify-content: center;
        }

        .lock-icon-container svg {
            transition: fill 0.3s, stroke 0.3s;
            width: 3.5rem;
            height: 3.5rem;
        }

        .status-text {
            text-align: center;
            font-size: 1.2em;
            font-weight: 500;
            margin-top: 1em;
            color: #444;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .countdown-timer {
            text-align: center;
            font-size: 1.1em;
            margin: 15px 0 0 0;
            color: var(--primary-dark);
            font-weight: 500;
            min-height: 1.5em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .countdown-timer .material-icons {
            font-size: 1.2em;
        }

        .countdown-timer.unavailable {
            color: #888;
            font-style: italic;
        }

        @media (max-width: 600px) {
            .lock-icon-container {
                width: 80px;
                height: 80px;
                margin: 2px 0;
                padding: 15px;
            }
            .lock-icon-container svg {
                width: 2rem;
                height: 2rem;
            }
            .status-text {
                font-size: 1em;
                margin-top: 0.3em;
            }
        }

        .sun-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-width: 80px;
        }

        .sun-times {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 0.9em;
            color: #444;
            line-height: 1.2;
        }

        .sun-time {
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
        }

        .sun-time .material-icons {
            color: #ff9800;
            font-size: 1.1em;
        }

        #sunIcon {
            color: #ff9800;
            animation: sunPulse 2s infinite;
            font-size: 1.3em;
        }

        @keyframes sunPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @media (max-width: 600px) {
            .sun-times {
                font-size: 0.8em;
            }
            .sun-info {
                min-width: 70px;
            }
        }
    </style>
</head>
<body>
    <div class="container unknown" id="mainContainer">
        <div class="header">
            <h1>Magnetic Lock Control</h1>
        </div>

        <div class="lock-icon-container">
            <span id="lockIcon"></span>
            <div id="lockStatusText" class="status-text">Checking status...</div>
        </div>

        <div id="countdownTimer" class="countdown-timer" style="display: none;"></div>

        <button id="lockButton" class="lock-button" onclick="toggleLock()">
            <span class="material-icons">lock</span>
            Toggle Lock
        </button>
        <div class="duration-buttons">
            <button onclick="unlockForDuration(10)" class="lock-button">10s</button>
            <button onclick="unlockForDuration(300)" class="lock-button">5m</button>
            <button onclick="unlockForDuration(1800)" class="lock-button">30m</button>
            <button onclick="unlockUntilSunset()" class="lock-button">Until Sunset</button>
        </div>

        <!-- Add debug button -->
        <button onclick="clearAllStates()" class="lock-button" style="background: #ff9800; margin-top: 10px;">
            <span class="material-icons">cleaning_services</span>
            Clear All States (Debug)
        </button>

        <div class="daily-code">
            <div class="daily-code-header">
                <span class="material-icons">key</span>
                <span>Daily Code</span>
            </div>
            <div id="dailyCode" class="code-display">Loading...</div>
            <div id="dailyCodeExpiry" class="code-expiry"></div>
        </div>

        <!-- Add One-Time Code section -->
        <div class="daily-code">
            <div class="daily-code-header">
                <span class="material-icons">vpn_key</span>
                <span>One-Time Code</span>
            </div>
            <div id="oneTimeCode" class="code-display">Loading...</div>
            <div id="oneTimeCodeExpiry" class="code-expiry"></div>
        </div>

        <div class="info-bar">
            <div class="info-item">
                <span class="material-icons">schedule</span>
                <span id="currentTime">--:--</span>
            </div>
            <div class="info-item">
                <span class="material-icons">calendar_today</span>
                <span id="currentDate">--</span>
            </div>
            <div class="info-item">
                <span class="material-icons">wb_sunny</span>
                <span id="weatherInfo">--</span>
            </div>
            <div class="info-item sun-info">
                <span class="material-icons" id="sunIcon">wb_sunny</span>
                <div class="sun-times">
                    <div class="sun-time">
                        <span class="material-icons" style="font-size: 0.9em;">nightlight_round</span>
                        <span id="sunsetTime">--:--</span>
                    </div>
                    <div class="sun-time">
                        <span class="material-icons" style="font-size: 0.9em;">wb_twilight</span>
                        <span id="sunriseTime">--:--</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="friesland-card">
            <div class="friesland-header">
                <span class="material-icons">warning</span>
                <span>Brandweer Status</span>
            </div>
            <div id="brandweerNotifications"></div>
            <div id="brandweerTimestamp" style="text-align: center; font-size: 0.8em; color: #888; margin-top: 5px; display: flex; align-items: center; justify-content: center; gap: 4px;">
                <span class="material-icons" style="font-size: 1em;">update</span>
                --
            </div>
        </div>

        <!-- Add Opener History section -->
        <div class="friesland-card">
            <div class="friesland-header">
                <span class="material-icons">history</span>
                <span>Lock History</span>
            </div>
            <div id="openerHistory"></div>
            <div id="openerTimestamp" style="text-align: center; font-size: 0.8em; color: #888; margin-top: 5px; display: flex; align-items: center; justify-content: center; gap: 4px;">
                <span class="material-icons" style="font-size: 1em;">update</span>
                --
            </div>
        </div>
    </div>

    <!-- Add version info -->
    <div id="versionInfo" class="version-info" style="text-align: center; margin-top: 20px; padding: 10px; font-size: 0.8em; color: #888; opacity: 0.5; border-top: 1px solid rgba(0,0,0,0.1);">
        <span id="versionNumber">v2.2.0</span>
        <span id="versionStatus" style="font-size: 0.9em; margin-left: 5px; color: #ff9800; display: none;">(YAML update required)</span>
    </div>

    <!-- Load configuration first -->
    <script src="version_tracking.js"></script>
    <script>
        const config = {
            HA_TOKEN: '',
            HA_URL: window.location.origin.replace('http://', 'https://'),
            VERSION: '2.2.0',
            timezone: 'Europe/Amsterdam',
            tasmotaSwitch: 'switch.tasmota',
            stateEntities: {
                dailyCode: "input_text.lockcontrol_daily_code",
                dailyCodeExpiry: "input_datetime.lockcontrol_daily_code_expiry",
                friesland: "sensor.brandweerdiensten",
                unlockEnd: "input_datetime.lock_unlock_end",
                oneTimeCode: "input_text.lockcontrol_one_time_code",
                oneTimeCodeExpiry: "input_datetime.lockcontrol_one_time_code_expiry",
                version: "sensor.lockcontrol_version",
                lastOpener: "input_text.lockcontrol_last_opener"
            }
        };

        let currentState = 'off';
        let unlockTimer = null;
        let timerInterval = null;
        let lockPerformed = false;

        function updateDateTime() {
            const now = new Date();
            document.getElementById('currentTime').textContent = now.toLocaleTimeString('nl-NL', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false,
                timeZone: config.timezone
            });
            document.getElementById('currentDate').textContent = now.toLocaleDateString('nl-NL', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                timeZone: config.timezone
            });
        }

        function updateDailyCode() {
            if (!config.HA_TOKEN) {
                console.error('No token available');
                document.getElementById('dailyCode').textContent = 'Error: No token';
                return;
            }

            // First check if it's night time
            fetch(`${config.HA_URL}/api/states/sun.sun`, {
                headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
            })
            .then(res => {
                if (!res.ok) {
                    throw new Error(`HTTP error! status: ${res.status}`);
                }
                return res.json();
            })
            .then(sunData => {
                const sunset = new Date(sunData.attributes.next_setting);
                const sunrise = new Date(sunData.attributes.next_rising);
                const now = new Date();
                const isNight = now >= sunset || now < sunrise;

                const dailyCode = document.getElementById('dailyCode');
                const dailyCodeExpiry = document.getElementById('dailyCodeExpiry');
                
                if (isNight) {
                    dailyCode.textContent = 'Code disabled at night';
                    dailyCodeExpiry.textContent = 'Available after sunrise';
                    return;
                }

                // If it's day time, proceed with normal code update
                fetch(`${config.HA_URL}/api/states/${config.stateEntities.dailyCode}`, {
                    headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
                })
                .then(res => {
                    if (!res.ok) {
                        throw new Error(`HTTP error! status: ${res.status}`);
                    }
                    return res.json();
                })
                .then(data => {
                    if (data && data.state && data.state !== 'unknown') {
                        dailyCode.textContent = data.state;
                        
                        fetch(`${config.HA_URL}/api/states/${config.stateEntities.dailyCodeExpiry}`, {
                            headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
                        })
                        .then(res => {
                            if (!res.ok) {
                                throw new Error(`HTTP error! status: ${res.status}`);
                            }
                            return res.json();
                        })
                        .then(expiryData => {
                            if (expiryData && expiryData.state) {
                                const expiry = new Date(expiryData.state);
                                dailyCodeExpiry.textContent = `Expires at ${expiry.toLocaleTimeString('nl-NL', { 
                                    hour: '2-digit', 
                                    minute: '2-digit', 
                                    hour12: false,
                                    timeZone: config.timezone 
                                })}`;
                            }
                        })
                        .catch(error => {
                            console.error('Error fetching expiry:', error);
                            dailyCodeExpiry.textContent = 'Error loading expiry';
                        });
                    } else {
                        dailyCode.textContent = 'No code available';
                        dailyCodeExpiry.textContent = '';
                    }
                })
                .catch(error => {
                    console.error('Error fetching daily code:', error);
                    document.getElementById('dailyCode').textContent = 'Error loading code';
                });
            })
            .catch(error => {
                console.error('Error checking sun state:', error);
                document.getElementById('dailyCode').textContent = 'Error checking time';
            });
        }

        function getLockState() {
            if (!config.HA_TOKEN) {
                console.error('No token available');
                document.getElementById('lockStatusText').textContent = 'Error: No token';
                return;
            }

            fetch(`${config.HA_URL}/api/states/${config.tasmotaSwitch}`, {
                headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
            })
            .then(res => {
                if (!res.ok) {
                    throw new Error(`HTTP error! status: ${res.status}`);
                }
                return res.json();
            })
            .then(data => {
                currentState = data.state;
                updateLockStatus();
            })
            .catch(error => {
                console.error('Error fetching lock state:', error);
                document.getElementById('lockStatusText').textContent = 'Error fetching status';
                currentState = 'unknown';
                updateLockStatus();
            });
        }

        function updateLockStatus() {
            const lockButton = document.getElementById('lockButton');
            const lockStatusText = document.getElementById('lockStatusText');
            const lockIcon = document.getElementById('lockIcon');
            const mainContainer = document.getElementById('mainContainer');

            // Check if all required elements exist
            if (!lockButton || !lockStatusText || !lockIcon || !mainContainer) {
                console.error('Required elements not found:', {
                    lockButton: !!lockButton,
                    lockStatusText: !!lockStatusText,
                    lockIcon: !!lockIcon,
                    mainContainer: !!mainContainer
                });
                return;
            }
            
            if (currentState === 'on') {
                // Locked state
                lockButton.innerHTML = '<span class="material-icons">lock_open</span> Unlock Door';
                lockButton.className = 'lock-button';
                lockStatusText.textContent = 'Locked';
                lockIcon.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="#388e3c" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" style="width:3.5em;height:3.5em;"><rect x="3" y="11" width="18" height="10" rx="2" fill="#43a047" stroke="#388e3c"/><path d="M7 11V7a5 5 0 0 1 10 0v4" stroke="#388e3c" fill="none"/><circle cx="12" cy="16" r="2" fill="#fff"/></svg>`;
                mainContainer.className = 'container locked';
            } else if (currentState === 'off') {
                // Unlocked state
                lockButton.innerHTML = '<span class="material-icons">lock</span> Lock Door';
                lockButton.className = 'lock-button locked';
                lockStatusText.textContent = 'Unlocked';
                lockIcon.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="#d32f2f" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" style="width:3.5em;height:3.5em;"><rect x="3" y="11" width="18" height="10" rx="2" fill="#e53935" stroke="#d32f2f"/><path d="M7 11V7a5 5 0 0 1 10 0" stroke="#d32f2f" fill="none"/><circle cx="12" cy="16" r="2" fill="#fff"/></svg>`;
                mainContainer.className = 'container unlocked';
            } else {
                // Unknown state
                lockButton.innerHTML = '<span class="material-icons">lock</span> Toggle Lock';
                lockButton.className = 'lock-button';
                lockStatusText.textContent = 'Unknown';
                lockIcon.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="#888" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" style="width:3.5em;height:3.5em;"><rect x="3" y="11" width="18" height="10" rx="2" fill="#eee" stroke="#888"/><path d="M7 11V7a5 5 0 0 1 10 0" stroke="#888" fill="none"/><circle cx="12" cy="16" r="2" fill="#888"/></svg>`;
                mainContainer.className = 'container unknown';
            }
        }

        // Add loading indicator function
        function showLoading(show) {
            let loadingDiv = document.getElementById('loadingIndicator');
            if (!loadingDiv) {
                loadingDiv = document.createElement('div');
                loadingDiv.id = 'loadingIndicator';
                loadingDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 20px 40px;
                    border-radius: 10px;
                    z-index: 1000;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                `;
                loadingDiv.innerHTML = `
                    <div class="spinner" style="
                        width: 20px;
                        height: 20px;
                        border: 3px solid #f3f3f3;
                        border-top: 3px solid var(--primary);
                        border-radius: 50%;
                        animation: spin 1s linear infinite;
                    "></div>
                    Loading...
                `;
                document.body.appendChild(loadingDiv);
            }
            loadingDiv.style.display = show ? 'flex' : 'none';
        }

        // Add function to record opener
        async function recordOpener(openerType) {
            try {
                await callService('input_text', 'set_value', config.stateEntities.lastOpener, {
                    value: `${openerType} at ${new Date().toLocaleString('nl-NL', { timeZone: config.timezone })}`
                });
            } catch (error) {
                console.error('Error recording opener:', error);
            }
        }

        // Update toggleLock function
        async function toggleLock() {
            try {
                setDurationButtonsEnabled(false);
                showLoading(true);

                if (currentState === 'on') {
                    await callService('switch', 'turn_off', config.tasmotaSwitch);
                    await recordOpener('Manual Toggle');
                    currentState = 'off';
                } else if (currentState === 'off') {
                    // Clear any active countdown when manually locking
                    if (timerInterval) {
                        clearInterval(timerInterval);
                        timerInterval = null;
                    }
                    // Reset the unlock end time
                    await callService('input_datetime', 'set_datetime', config.stateEntities.unlockEnd, {
                        datetime: "1970-01-01T00:00:00"
                    });
                    // Hide the countdown display
                    document.getElementById('countdownTimer').style.display = 'none';
                    
                    await callService('switch', 'turn_on', config.tasmotaSwitch);
                    currentState = 'on';
                }
                updateLockStatus();
            } catch (error) {
                console.error('Error toggling lock:', error);
                showError('Failed to toggle lock');
            } finally {
                setDurationButtonsEnabled(true);
                showLoading(false);
            }
        }

        async function unlockUntilSunset() {
            console.log('=== Unlock Until Sunset Debug ===');
            console.log('Attempting to unlock until sunset...');
            console.log('Current lock state:', currentState);
            
            // Check if the door is locked (currentState === 'on' means locked)
            if (currentState !== 'on') {
                console.log('Door is not locked - current state:', currentState);
                alert('Please lock the door first before using this option.');
                return;
            }

            try {
                setDurationButtonsEnabled(false);
                showLoading(true);

                const response = await fetch(`${config.HA_URL}/api/states/sun.sun`, {
                    headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch sunset time');
                }

                const data = await response.json();
                const sunset = new Date(data.attributes.next_setting);
                const sunrise = new Date(data.attributes.next_rising);
                const now = new Date();
                
                // If sunset is tomorrow, get today's sunset
                if (sunset.getDate() > now.getDate()) {
                    sunset.setDate(sunset.getDate() - 1);
                }
                
                console.log('Current time:', now.toLocaleString());
                console.log('Sunset time:', sunset.toLocaleString());
                console.log('Sunrise time:', sunrise.toLocaleString());
                console.log('Time until sunset:', Math.floor((sunset - now) / 1000 / 60), 'minutes');
                console.log('Is after sunset?', now >= sunset);
                console.log('Is before sunrise?', now < sunrise);
                console.log('Is night?', now >= sunset || now < sunrise);
                
                // Unlock the door
                await callService('switch', 'turn_off', config.tasmotaSwitch);
                await recordOpener('Until Sunset');
                currentState = 'off';
                updateLockStatus();
                
                if (timerInterval) {
                    console.log('Clearing existing timer');
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                
                // Set the unlock end time to sunset
                await callService('input_datetime', 'set_datetime', config.stateEntities.unlockEnd, {
                    datetime: sunset.toISOString()
                });
                
                console.log('Timer state stored');
                timerInterval = setInterval(() => {
                    const currentTime = new Date();
                    const timeLeft = sunset.getTime() - currentTime.getTime();
                    
                    console.log('Countdown update:', {
                        currentTime: currentTime.toLocaleString(),
                        timeLeft: Math.floor(timeLeft / 1000 / 60) + ' minutes'
                    });
                    
                    if (timeLeft <= 0) {
                        console.log('Timer expired - locking door');
                        callService('switch', 'turn_on', config.tasmotaSwitch);
                        clearInterval(timerInterval);
                        timerInterval = null;
                        updateTimerDisplay(null);
                        clearTimerState();
                    } else {
                        updateTimerDisplay({ endTime: sunset });
                    }
                }, 1000);
                
                updateTimerDisplay({ endTime: sunset });
                showSuccess('Door unlocked until sunset');
            } catch (error) {
                console.error('Error in unlockUntilSunset:', error);
                showError('Failed to unlock until sunset');
            } finally {
                setDurationButtonsEnabled(true);
                showLoading(false);
            }
        }

        function updateTimerDisplay(timerState) {
            const countdownTimer = document.getElementById('countdownTimer');
            if (!timerState) {
                countdownTimer.style.display = 'none';
                return;
            }

            const now = new Date();
            const endTime = new Date(timerState.endTime);
            const timeLeft = endTime - now;

            if (timeLeft <= 0) {
                countdownTimer.style.display = 'none';
                return;
            }

            const hours = Math.floor(timeLeft / (1000 * 60 * 60));
            const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

            if (hours > 0) {
                countdownTimer.textContent = `Locks in ${hours}h ${minutes}m`;
            } else if (minutes > 0) {
                countdownTimer.textContent = `Locks in ${minutes}m ${seconds}s`;
            } else {
                countdownTimer.textContent = `Locks in ${seconds}s`;
            }
            countdownTimer.style.display = 'block';
        }

        // Load configuration from config file
        async function loadConfig() {
            try {
                console.log('Starting config load...');
                
                // Add cache-busting parameter
                const timestamp = new Date().getTime();
                const baseUrl = window.location.origin;
                const configPaths = [
                    `${baseUrl}/local/lockcontrol/config.js?t=${timestamp}`,
                    `${baseUrl}/local/config.js?t=${timestamp}`,
                    `config.js?t=${timestamp}`,
                    `../config.js?t=${timestamp}`
                ];

                console.log('Trying config paths:', configPaths);

                let configLoaded = false;
                for (const path of configPaths) {
                    try {
                        console.log('Attempting to load config from:', path);
                        const response = await fetch(path, {
                            method: 'GET',
                            headers: {
                                'Cache-Control': 'no-cache, no-store, must-revalidate',
                                'Pragma': 'no-cache',
                                'Expires': '0'
                            },
                            credentials: 'same-origin'
                        });
                        
                        if (response.ok) {
                            const text = await response.text();
                            console.log('Config file loaded successfully from:', path);
                            
                            // Try to find token in JavaScript format first
                            let match = text.match(/HA_TOKEN:\s*'([^']+)'/);
                            if (!match) {
                                match = text.match(/HA_TOKEN=([^\s]+)/);
                            }
                            
                            if (match) {
                                config.HA_TOKEN = match[1];
                                console.log('Token found and set from file');
                                
                                // Store token in localStorage as backup
                                try {
                                    localStorage.setItem('ha_token', config.HA_TOKEN);
                                    console.log('Token stored in localStorage');
                                } catch (e) {
                                    console.warn('Could not store token in localStorage:', e);
                                }
                            } else {
                                console.warn('No token found in config file');
                            }

                            // Try to find URL in JavaScript format first
                            let urlMatch = text.match(/HA_URL:\s*'([^']+)'/);
                            if (!urlMatch) {
                                urlMatch = text.match(/HA_URL=([^\s]+)/);
                            }
                            
                            if (urlMatch) {
                                config.HA_URL = urlMatch[1];
                                console.log('URL found and set from file:', config.HA_URL);
                                
                                // Store URL in localStorage as backup
                                try {
                                    localStorage.setItem('ha_url', config.HA_URL);
                                    console.log('URL stored in localStorage');
                                } catch (e) {
                                    console.warn('Could not store URL in localStorage:', e);
                                }
                            } else {
                                console.warn('No URL found in config file');
                            }
                            
                            configLoaded = true;
                            break;
                        } else {
                            console.warn(`Failed to load config from ${path}: ${response.status} ${response.statusText}`);
                        }
                    } catch (e) {
                        console.warn(`Error loading config from ${path}:`, e);
                    }
                }

                if (!configLoaded) {
                    console.log('Failed to load config from any path, trying localStorage');
                    // Try to recover from localStorage
                    const storedToken = localStorage.getItem('ha_token');
                    const storedUrl = localStorage.getItem('ha_url');
                    
                    if (storedToken) {
                        console.log('Using token from localStorage');
                        config.HA_TOKEN = storedToken;
                    }
                    if (storedUrl) {
                        console.log('Using URL from localStorage');
                        config.HA_URL = storedUrl;
                    }
                    
                    if (!storedToken || !storedUrl) {
                        throw new Error('Could not load configuration from any source');
                    }
                }

                // Verify we have the required values
                if (!config.HA_TOKEN || !config.HA_URL) {
                    console.error('Missing configuration values:', {
                        hasToken: !!config.HA_TOKEN,
                        hasUrl: !!config.HA_URL,
                        tokenLength: config.HA_TOKEN?.length,
                        url: config.HA_URL
                    });
                    throw new Error('Missing required configuration values');
                }

                console.log('Configuration loaded successfully:', {
                    url: config.HA_URL,
                    hasToken: !!config.HA_TOKEN,
                    tokenLength: config.HA_TOKEN.length
                });

                // Verify token is valid by making a test request
                try {
                    const testResponse = await fetch(`${config.HA_URL}/api/`, {
                        headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
                    });
                    if (!testResponse.ok) {
                        throw new Error(`Token validation failed: ${testResponse.status}`);
                    }
                    console.log('Token validation successful');
                } catch (error) {
                    console.error('Token validation failed:', error);
                    throw new Error('Invalid token');
                }

            } catch (error) {
                console.error('Error loading config:', error);
                showError('Failed to load configuration. Please check your config file and try clearing your browser cache.');
                throw error;
            }
        }

        // Add a function to clear cache and reload
        function clearCacheAndReload() {
            try {
                localStorage.clear();
                sessionStorage.clear();
                window.location.reload(true);
            } catch (e) {
                console.error('Error clearing cache:', e);
                window.location.reload(true);
            }
        }

        // Add clear cache button for mobile devices
        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
            const clearButton = document.createElement('button');
            clearButton.className = 'lock-button warning';
            clearButton.style.marginTop = '10px';
            clearButton.innerHTML = '<span class="material-icons">cleaning_services</span> Clear Cache & Reload';
            clearButton.onclick = clearCacheAndReload;
            document.querySelector('.container').appendChild(clearButton);
        }

        // Add unlock duration functions
        async function unlockForDuration(seconds) {
            try {
                setDurationButtonsEnabled(false);
                showLoading(true);
                
                // First unlock the door
                await callService('switch', 'turn_off', config.tasmotaSwitch);
                await recordOpener(`${seconds} seconds timer`);
                currentState = 'off';
                updateLockStatus();

                // Calculate and set the unlock end time
                const endTime = new Date(Date.now() + seconds * 1000);
                const year = endTime.getFullYear();
                const month = String(endTime.getMonth() + 1).padStart(2, '0');
                const day = String(endTime.getDate()).padStart(2, '0');
                const hours = String(endTime.getHours()).padStart(2, '0');
                const minutes = String(endTime.getMinutes()).padStart(2, '0');
                const secs = String(endTime.getSeconds()).padStart(2, '0');
                
                const formattedDate = `${year}-${month}-${day} ${hours}:${minutes}:${secs}`;
                
                await callService('input_datetime', 'set_datetime', config.stateEntities.unlockEnd, {
                    datetime: formattedDate
                });

                showSuccess(`Door unlocked for ${seconds} seconds`);
                
                // Update countdown timer immediately
                updateCountdownTimer();
            } catch (error) {
                console.error('Error unlocking door:', error);
                showError('Failed to unlock door');
            } finally {
                setDurationButtonsEnabled(true);
                showLoading(false);
            }
        }

        // Update Friesland sensor function
        async function updateFrieslandSensor() {
            try {
                console.log('=== Brandweer Debug Info ===');
                
                // Get history for last 24 hours
                const now = new Date();
                const startTime = new Date(now.getTime() - (24 * 60 * 60 * 1000));
                console.log('Fetching history from:', startTime.toISOString());
                
                const historyResponse = await fetch(`${config.HA_URL}/api/history/period/${startTime.toISOString()}?filter_entity_id=${config.stateEntities.friesland}`, {
                    headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
                });

                if (!historyResponse.ok) {
                    throw new Error(`Failed to get history: ${historyResponse.status}`);
                }

                const historyData = await historyResponse.json();
                console.log('History data:', historyData);
                
                const historyEntries = historyData[0] || [];
                console.log('History entries:', historyEntries);

                const brandweerNotifications = document.getElementById('brandweerNotifications');
                const brandweerTimestamp = document.getElementById('brandweerTimestamp');
                
                // Get the last 3 entries
                const lastEntries = historyEntries.slice(-3).reverse();
                console.log('Last 3 entries:', lastEntries);

                // Update timestamp with current time
                const currentTime = new Date().toLocaleTimeString('nl-NL', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
                brandweerTimestamp.innerHTML = `<span class="material-icons">update</span> ${currentTime}`;

                if (lastEntries.length > 0) {
                    // Create entries for each state
                    const entriesHTML = lastEntries.map(entry => {
                        console.log('Processing entry:', entry);
                        
                        // Format the message
                        let message = entry.state;
                        
                        // Add priority if it starts with P
                        if (message.startsWith('P')) {
                            const priority = message.split(' ')[0];
                            message = message.replace(priority, `<strong>${priority}</strong>`);
                        }
                        
                        // Add location if it contains a city name
                        const cities = ['Drachten', 'Leeuwarden', 'Sneek', 'Heerenveen', 'Bolsward'];
                        for (const city of cities) {
                            if (message.includes(city)) {
                                message = message.replace(city, `<strong>${city}</strong>`);
                                break;
                            }
                        }

                        // Get the time from the last_changed timestamp
                        const time = new Date(entry.last_changed).toLocaleTimeString('nl-NL', {
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: false
                        });
                        console.log('Entry time:', {
                            last_changed: entry.last_changed,
                            formatted_time: time,
                            state: entry.state
                        });
                        
                        return `
                            <div class="brandweer-entry">
                                <span class="material-icons">warning</span>
                                <div class="brandweer-content">
                                    <div>${message}</div>
                                    <div class="brandweer-time">${time}</div>
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                    brandweerNotifications.innerHTML = entriesHTML;
                    
                    // Show warning if the most recent state indicates active alert
                    if (lastEntries[0].state !== 'none') {
                        showError('Brandweer sensor is active!');
                    }
                } else {
                    brandweerNotifications.innerHTML = `
                        <div class="brandweer-entry">
                            <span class="material-icons">check_circle</span>
                            <div class="brandweer-content">
                                <div>No active alerts</div>
                                <div class="brandweer-time">${currentTime}</div>
                            </div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error updating Friesland sensor:', error);
                document.getElementById('brandweerNotifications').innerHTML = `
                    <div class="brandweer-entry">
                        <span class="material-icons">error</span>
                        <div class="brandweer-content">
                            <div>Error loading data</div>
                            <div class="brandweer-time">--:--</div>
                        </div>
                    </div>
                `;
            }
        }

        // Add success/error message functions
        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'success-message';
            successDiv.textContent = message;
            document.body.appendChild(successDiv);
            setTimeout(() => successDiv.remove(), 3000);
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        }

        // Add function to enable/disable duration buttons
        function setDurationButtonsEnabled(enabled) {
            const buttons = document.querySelectorAll('.duration-buttons .lock-button');
            buttons.forEach(button => {
                button.disabled = !enabled;
            });
        }

        // Re-add the countdown timer function
        async function updateCountdownTimer() {
            try {
                const response = await fetch(`${config.HA_URL}/api/states/${config.stateEntities.unlockEnd}`, {
                    headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                const countdownTimer = document.getElementById('countdownTimer');
                
                if (data && data.state) {
                    const unlockEnd = new Date(data.state);
                    const now = new Date();
                    const isManualUnlock = unlockEnd.getTime() === new Date("1970-01-01T00:00:00").getTime();
                    
                    if (!isManualUnlock && unlockEnd > now) {
                        const diff = unlockEnd - now;
                        const hours = Math.floor(diff / (1000 * 60 * 60));
                        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                        const seconds = Math.floor((diff % (1000 * 60)) / 1000);
                        
                        if (hours > 0) {
                            countdownTimer.textContent = `Locks in ${hours}h ${minutes}m`;
                        } else if (minutes > 0) {
                            countdownTimer.textContent = `Locks in ${minutes}m ${seconds}s`;
                        } else {
                            countdownTimer.textContent = `Locks in ${seconds}s`;
                        }
                        countdownTimer.style.display = 'block';
                    } else if (!isManualUnlock && unlockEnd <= now) {
                        // Timer has expired, lock the door
                        if (currentState === 'off') {
                            const lockResponse = await fetch(`${config.HA_URL}/api/services/switch/turn_on`, {
                                method: 'POST',
                                headers: {
                                    'Authorization': `Bearer ${config.HA_TOKEN}`,
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    entity_id: config.tasmotaSwitch
                                })
                            });

                            if (lockResponse.ok) {
                                currentState = 'on';
                                updateLockStatus();
                                showSuccess('Door locked');
                            }
                        }
                        countdownTimer.style.display = 'none';
                    } else {
                        countdownTimer.style.display = 'none';
                    }
                } else {
                    countdownTimer.style.display = 'none';
                }
            } catch (error) {
                console.error('Error updating countdown timer:', error);
                document.getElementById('countdownTimer').style.display = 'none';
            }
        }

        // Add clear all states function
        async function clearAllStates() {
            try {
                showLoading(true);
                
                // Clear timer interval
                if (unlockTimer) {
                    clearInterval(unlockTimer);
                    unlockTimer = null;
                }
                
                // Reset unlock end time in Home Assistant
                await callService('input_datetime', 'set_datetime', config.stateEntities.unlockEnd, {
                    datetime: "1970-01-01T00:00:00"
                });
                
                // Hide countdown timer
                document.getElementById('countdownTimer').style.display = 'none';
                
                // Force lock the door
                await callService('switch', 'turn_on', config.tasmotaSwitch);
                
                // Update UI
                currentState = 'on';
                updateLockStatus();
                showSuccess('All states cleared and door locked');
                
            } catch (error) {
                console.error('Error clearing states:', error);
                showError('Failed to clear states');
            } finally {
                showLoading(false);
            }
        }

        // Add this function to update weather information
        async function updateWeatherInfo() {
            try {
                if (!config.HA_TOKEN) {
                    console.error('No authentication token available');
                    document.getElementById('weatherInfo').textContent = '--';
                    return;
                }

                const response = await fetch(`${config.HA_URL}/api/states/weather.forecast_home`, {
                    headers: { 
                        'Authorization': `Bearer ${config.HA_TOKEN}`,
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Failed to fetch weather data: ${response.status}`);
                }

                const data = await response.json();
                if (data && data.state && data.attributes) {
                    const temp = data.attributes.temperature;
                    const condition = data.state;
                    document.getElementById('weatherInfo').textContent = `${condition}, ${temp}C`;
                } else {
                    document.getElementById('weatherInfo').textContent = '--';
                }
            } catch (error) {
                console.error('Error updating weather info:', error);
                document.getElementById('weatherInfo').textContent = '--';
            }
        }

        // Add one-time code functions
        async function updateOneTimeCode() {
            if (!config.HA_TOKEN) {
                console.error('No token available');
                document.getElementById('oneTimeCode').textContent = 'Error: No token';
                return;
            }

            try {
                const response = await fetch(`${config.HA_URL}/api/states/${config.stateEntities.oneTimeCode}`, {
                    headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                const oneTimeCode = document.getElementById('oneTimeCode');
                const oneTimeCodeExpiry = document.getElementById('oneTimeCodeExpiry');
                
                if (data && data.state && data.state !== 'unknown' && data.state !== '') {
                    oneTimeCode.textContent = data.state;
                    
                    const expiryResponse = await fetch(`${config.HA_URL}/api/states/${config.stateEntities.oneTimeCodeExpiry}`, {
                        headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
                    });
                    
                    if (expiryResponse.ok) {
                        const expiryData = await expiryResponse.json();
                        if (expiryData && expiryData.state) {
                            const expiry = new Date(expiryData.state);
                            oneTimeCodeExpiry.textContent = `Expires at ${expiry.toLocaleTimeString('nl-NL', { 
                                hour: '2-digit', 
                                minute: '2-digit', 
                                hour12: false,
                                timeZone: config.timezone 
                            })}`;
                        }
                    }
                } else {
                    oneTimeCode.textContent = 'No code available';
                    oneTimeCodeExpiry.textContent = '';
                }
            } catch (error) {
                console.error('Error fetching one-time code:', error);
                document.getElementById('oneTimeCode').textContent = 'Error loading code';
            }
        }

        // Function to generate a new one-time code
        async function generateOneTimeCode(expiryMinutes = 60) {
            try {
                const response = await fetch(`${config.HA_URL}/api/services/event/fire`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${config.HA_TOKEN}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        event_type: 'generate_one_time_code',
                        event_data: {
                            expiry_minutes: expiryMinutes
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to generate one-time code');
                }

                // Wait a moment for the automation to complete
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Update the display
                await updateOneTimeCode();
                
                showSuccess('New one-time code generated');
            } catch (error) {
                console.error('Error generating one-time code:', error);
                showError('Failed to generate one-time code: ' + error.message);
            }
        }

        // Function to validate a code
        async function validateCode(code) {
            try {
                const response = await fetch(`${config.HA_URL}/api/services/mqtt/publish`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${config.HA_TOKEN}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        topic: 'keylock/access_code',
                        payload: code
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to validate code');
                }

                // Wait a moment for the automation to complete
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Update the display
                await updateOneTimeCode();
                
                showSuccess('Code validated');
            } catch (error) {
                console.error('Error validating code:', error);
                showError('Failed to validate code: ' + error.message);
            }
        }

        // Add function to update opener history
        async function updateOpenerHistory() {
            try {
                if (!config.HA_TOKEN) {
                    console.error('No token available');
                    return;
                }

                // Get history for last 24 hours
                const now = new Date();
                const startTime = new Date(now.getTime() - (24 * 60 * 60 * 1000));
                
                const historyResponse = await fetch(`${config.HA_URL}/api/history/period/${startTime.toISOString()}?filter_entity_id=${config.stateEntities.lastOpener}`, {
                    headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
                });

                if (!historyResponse.ok) {
                    throw new Error(`Failed to get history: ${historyResponse.status}`);
                }

                const historyData = await historyResponse.json();
                const historyEntries = historyData[0] || [];
                
                const openerHistory = document.getElementById('openerHistory');
                const openerTimestamp = document.getElementById('openerTimestamp');
                
                // Get the last 5 entries
                const lastEntries = historyEntries.slice(-5).reverse();

                // Update timestamp with current time
                const currentTime = new Date().toLocaleTimeString('nl-NL', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
                openerTimestamp.innerHTML = `<span class="material-icons">update</span> ${currentTime}`;

                if (lastEntries.length > 0) {
                    // Create entries for each state
                    const entriesHTML = lastEntries.map(entry => {
                        const time = new Date(entry.last_changed).toLocaleTimeString('nl-NL', {
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: false
                        });
                        
                        return `
                            <div class="brandweer-entry">
                                <span class="material-icons">lock_open</span>
                                <div class="brandweer-content">
                                    <div>${entry.state}</div>
                                    <div class="brandweer-time">${time}</div>
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                    openerHistory.innerHTML = entriesHTML;
                } else {
                    openerHistory.innerHTML = `
                        <div class="brandweer-entry">
                            <span class="material-icons">history</span>
                            <div class="brandweer-content">
                                <div>No history available</div>
                                <div class="brandweer-time">--:--</div>
                            </div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error updating opener history:', error);
                document.getElementById('openerHistory').innerHTML = `
                    <div class="brandweer-entry">
                        <span class="material-icons">error</span>
                        <div class="brandweer-content">
                            <div>Error loading history</div>
                            <div class="brandweer-time">--:--</div>
                        </div>
                    </div>
                `;
            }
        }

        // Update init function to include opener history updates
        async function init() {
            try {
                // First load and validate configuration
                await loadConfig();
                
                // Update date/time display
                updateDateTime();
                setInterval(updateDateTime, 1000);
                
                // Update daily code
                updateDailyCode();
                setInterval(updateDailyCode, 60000);
                
                // Update one-time code more frequently
                updateOneTimeCode();
                setInterval(updateOneTimeCode, 10000); // Update every 10 seconds
                
                // Update Friesland sensor
                updateFrieslandSensor();
                setInterval(updateFrieslandSensor, 300000); // Update every 5 minutes
                
                // Get initial lock state
                await getLockState();
                setInterval(getLockState, 30000);
                
                // Add countdown timer updates
                updateCountdownTimer();
                setInterval(updateCountdownTimer, 1000); // Update every second
                
                // Update weather information
                await updateWeatherInfo();
                setInterval(updateWeatherInfo, 300000); // Update every 5 minutes
                
                // Update opener history
                await updateOpenerHistory();
                setInterval(updateOpenerHistory, 60000); // Update every minute
                
                // Only update sunset time after successful initialization
                await updateSunsetTime();
                setInterval(updateSunsetTime, 3600000); // Update every hour
                
                console.log('Initialization complete');
            } catch (error) {
                console.error('Error initializing:', error);
                showError('Failed to initialize. Please check your configuration and try again.');
            }
        }

        // Start the application
        init();

        // Update the updateSunsetTime function
        async function updateSunsetTime() {
            try {
                if (!config.HA_TOKEN) {
                    console.error('No authentication token available');
                    document.getElementById('sunsetTime').textContent = '--:--';
                    document.getElementById('sunriseTime').textContent = '--:--';
                    return;
                }

                const response = await fetch(`${config.HA_URL}/api/states/sun.sun`, {
                    headers: { 
                        'Authorization': `Bearer ${config.HA_TOKEN}`,
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache'
                    }
                });
                
                if (!response.ok) {
                    console.error('Failed to fetch sun data:', response.status, response.statusText);
                    document.getElementById('sunsetTime').textContent = '--:--';
                    document.getElementById('sunriseTime').textContent = '--:--';
                    return;
                }
                
                const data = await response.json();
                const sunset = new Date(data.attributes.next_setting);
                const sunrise = new Date(data.attributes.next_rising);
                const now = new Date();
                
                // If sunset is tomorrow, get today's sunset
                if (sunset.getDate() > now.getDate()) {
                    sunset.setDate(sunset.getDate() - 1);
                }
                
                // Debug information
                console.log('=== Sunset Debug Information ===');
                console.log('Current time:', now.toLocaleString());
                console.log('Sunset time:', sunset.toLocaleString());
                console.log('Sunrise time:', sunrise.toLocaleString());
                console.log('Time until sunset:', Math.floor((sunset - now) / 1000 / 60), 'minutes');
                console.log('Is after sunset?', now >= sunset);
                console.log('Is before sunrise?', now < sunrise);
                console.log('Is night?', now >= sunset || now < sunrise);
                
                // Update UI elements
                document.getElementById('sunsetTime').textContent = formatTime(sunset);
                document.getElementById('sunriseTime').textContent = formatTime(sunrise);
                
                const sunIcon = document.getElementById('sunIcon');
                if (now >= sunset || now < sunrise) {
                    sunIcon.textContent = 'nightlight_round';
                    sunIcon.style.color = '#64b5f6';
                } else {
                    sunIcon.textContent = 'wb_sunny';
                    sunIcon.style.color = '#ff9800';
                }
                
                const sunsetBtn = document.querySelector('.duration-buttons .lock-button:last-child');
                if (sunsetBtn) {
                    // Check if it's night time (between sunset and sunrise)
                    const isNight = now >= sunset || now < sunrise;
                    if (isNight) {
                        console.log('Disabling sunset button - night time');
                        sunsetBtn.style.backgroundColor = '#888';
                        sunsetBtn.style.cursor = 'not-allowed';
                        sunsetBtn.textContent = 'Not available at night';
                        sunsetBtn.disabled = true;
                    } else {
                        console.log('Enabling sunset button - day time');
                        sunsetBtn.style.backgroundColor = '';
                        sunsetBtn.style.cursor = '';
                        sunsetBtn.textContent = `Unlock until ${formatTime(sunset)}`;
                        sunsetBtn.disabled = false;
                    }
                }
            } catch (error) {
                console.error('Error updating sun times:', error);
                document.getElementById('sunsetTime').textContent = '--:--';
                document.getElementById('sunriseTime').textContent = '--:--';
            }
        }

        // Update the formatTime function to handle timezone
        function formatTime(date) {
            return date.toLocaleTimeString('nl-NL', { 
                hour: '2-digit', 
                minute: '2-digit', 
                hour12: false,
                timeZone: config.timezone 
            });
        }

        function checkSunsetStatus(simulatedTime) {
            console.log('=== Sunset Status Check ===');
            console.log('Current time:', new Date().toLocaleString());
            console.log('Simulated time:', simulatedTime ? simulatedTime.toLocaleString() : 'None');
            
            fetch(`${config.HA_URL}/api/states/sun.sun`, {
                headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
            })
            .then(res => res.json())
            .then(data => {
                console.log('Raw sun data:', data);
                
                const sunset = new Date(data.attributes.next_setting);
                const sunrise = new Date(data.attributes.next_rising);
                const sunsetBtn = document.getElementById('btnSunset');
                const now = simulatedTime || new Date();
                
                console.log('Time values:');
                console.log('- Current time:', now.toLocaleString());
                console.log('- Sunset time:', sunset.toLocaleString());
                console.log('- Sunrise time:', sunrise.toLocaleString());
                console.log('- Is after sunset?', now >= sunset);
                console.log('- Is before sunrise?', now < sunrise);
                console.log('- Is night?', now >= sunset && now < sunrise);
                
                // If it's after sunset and before next sunrise, button should be disabled
                if (now >= sunset && now < sunrise) {
                    console.log('Nighttime detected - disabling button');
                    sunsetBtn.style.backgroundColor = '#888';
                    sunsetBtn.style.cursor = 'not-allowed';
                    sunsetBtn.textContent = 'Not available at night';
                    sunsetBtn.disabled = true;
                } 
                // If it's after sunrise and before sunset, button should be enabled
                else {
                    console.log('Daytime detected - enabling button');
                    sunsetBtn.style.backgroundColor = '';
                    sunsetBtn.style.cursor = '';
                    sunsetBtn.textContent = `Unlock until ${formatTime(sunset)}`;
                    sunsetBtn.disabled = false;
                }
            })
            .catch(error => {
                console.error('Error in checkSunsetStatus:', error);
            });
        }

        async function initializeApp() {
            try {
                await loadConfig();
                await verifyAuth();
                
                // Initialize the rest of your application
                const state = await getLockState(false);
                
                // Set up polling interval
                setInterval(() => {
                    getLockState(true).catch(error => {
                        console.error('Background poll error:', error);
                    });
                }, 60000);

                updateInfoBar();
                setInterval(updateInfoBar, 60000);

                updateSunsetTime();
                setInterval(updateSunsetTime, 3600000);
                
                // Initialize timer if unlocked
                if (state === 'off') {
                    initializeTimer();
                }
                
                // Check sunset status and set up periodic checks
                checkSunsetStatus();
                setInterval(checkSunsetStatus, 60000);
                
            } catch (error) {
                console.error('Error initializing app:', error);
                document.getElementById('lockStatusText').textContent = 'Error initializing app';
                document.getElementById('lockStatusText').className = 'status-text';
            }
        }

        // Function to call Home Assistant services
        async function callService(domain, service, entityId, data = {}) {
            try {
                const response = await fetch(`${window.location.origin}/api/services/${domain}/${service}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${config.HA_TOKEN}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        entity_id: entityId,
                        ...data
                    })
                });

                if (!response.ok) {
                    throw new Error(`Service call failed: ${response.statusText}`);
                }

                return await response.json();
            } catch (error) {
                console.error('Error calling service:', error);
                throw error;
            }
        }
    </script>
</body>
</html>