<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Magnetic Lock Control</title>
  <link rel="icon" href="/local/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap">
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@6.5.95/css/materialdesignicons.min.css">
  <style>
    :root {
      --primary: #1976d2;
      --primary-dark: #1565c0;
      --accent: #388e3c;
      --danger: #d32f2f;
      --bg: #f0f2f5;
      --card-bg: #fff;
      --shadow: 0 4px 24px rgba(0,0,0,0.08);
      --radius: 18px;
      --transition: 0.2s cubic-bezier(.4,0,.2,1);
    }
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: var(--bg);
      font-family: 'Roboto', sans-serif;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    .container {
      max-width: 420px;
      margin: 0 auto;
      background: var(--card-bg);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 20px 20px 10px 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
      transition: border-color 0.3s;
      border: 4px solid #bbb;
    }
    .container.locked {
      border-color: #43a047;
    }
    .container.unlocked {
      border-color: #e53935;
    }
    .container.unknown {
      border-color: #bbb;
    }
    .lock-icon-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 10px 0;
      padding: 20px;
      background: rgba(0,0,0,0.03);
      border-radius: 50%;
      width: 120px;
      height: 120px;
      justify-content: center;
    }
    .lock-icon-container svg {
      transition: fill 0.3s, stroke 0.3s;
      width: 3.5rem;
      height: 3.5rem;
    }
    .status-text {
      text-align: center;
      font-size: 1.2em;
      font-weight: 500;
      margin-top: 1em;
      color: #444;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .loading {
      text-align: center;
      color: #888;
      font-size: 0.9em;
      margin: 10px 0;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .loading .material-icons {
      font-size: 1.2em;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      100% { transform: rotate(360deg); }
    }
    .btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      margin: 10px 0;
      padding: 15px 0;
      font-size: 1.1em;
      border: none;
      border-radius: 10px;
      background: var(--primary);
      color: #fff;
      cursor: pointer;
      transition: all var(--transition);
      font-weight: 500;
      box-shadow: 0 2px 8px rgba(25, 118, 210, 0.08);
      -webkit-appearance: none;
      appearance: none;
      gap: 8px;
    }
    .btn .material-icons {
      font-size: 1.2em;
    }
    .btn:active {
      transform: scale(0.98);
      box-shadow: 0 1px 4px rgba(25, 118, 210, 0.08);
    }
    .btn:disabled {
      background: #b0b0b0;
      cursor: not-allowed;
      color: #eee;
      box-shadow: none;
    }
    .toggle-btn {
      background: var(--accent);
      margin-bottom: 15px;
    }
    .toggle-btn.unlocked {
      background: var(--danger);
    }
    .reason {
      font-size: 0.9em;
      color: #666;
      text-align: center;
      margin: 5px 0;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .reason .material-icons {
      font-size: 1.1em;
    }
    .timer {
      text-align: center;
      font-size: 1.1em;
      margin: 15px 0 0 0;
      color: var(--primary-dark);
      font-weight: 500;
      min-height: 1.5em;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }
    .timer .material-icons {
      font-size: 1.2em;
    }
    .timer.unavailable {
      color: #888;
      font-style: italic;
    }
    .info-bar {
      width: 100%;
      background: rgba(0, 0, 0, 0.03);
      border-radius: 12px;
      padding: 12px 15px;
      margin-top: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9em;
      color: #444;
    }
    .info-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .info-item .material-icons {
      font-size: 1.2em;
    }
    .notification-item {
      display: flex;
      align-items: center;
      margin-top: 8px;
      font-size: 0.9em;
      color: #666;
      gap: 4px;
    }
    .notification-item .material-icons {
      font-size: 1.1em;
    }
    #brandweerTimestamp {
      text-align: center;
      font-size: 0.8em;
      color: #888;
      margin-top: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }
    #brandweerTimestamp .material-icons {
      font-size: 1em;
    }
    @media (max-width: 600px) {
      .container {
        max-width: 100%;
        margin: 0;
        padding: 8px 15px 3px 15px;
        min-height: calc(100vh - 40px);
        height: calc(100vh - 40px);
        overflow: hidden;
        border-width: 6px;
        display: flex;
        flex-direction: column;
      }
      .lock-icon-container {
        width: 80px;
        height: 80px;
        margin: 2px 0;
        padding: 15px;
      }
      .lock-icon-container svg {
        width: 2rem;
        height: 2rem;
      }
      .status-text {
        font-size: 1em;
        margin-top: 0.3em;
      }
      .btn {
        font-size: 0.95em;
        padding: 8px 0;
        margin: 4px 0;
      }
      .timer {
        font-size: 0.9em;
        margin: 8px 0 0 0;
      }
      .reason {
        font-size: 0.8em;
        margin: 2px 0;
      }
      .info-bar {
        padding: 6px 8px;
        font-size: 0.75em;
        margin-top: 8px;
      }
      .notification-item {
        margin-top: 3px;
        font-size: 0.8em;
      }
      #brandweerTimestamp {
        margin-top: 3px;
        font-size: 0.75em;
      }
    }
    .brandweer-entry {
      display: flex;
      align-items: flex-start;
      margin: 4px 0;
      padding: 6px;
      background: rgba(0,0,0,0.03);
      border-radius: 8px;
      font-size: 0.8em;
    }
    .brandweer-entry .material-icons {
      font-size: 1.1em;
      margin-right: 6px;
      color: #d32f2f;
    }
    .brandweer-content {
      flex: 1;
    }
    .brandweer-time {
      font-size: 0.75em;
      color: #888;
      margin-top: 2px;
    }
    @media (max-width: 600px) {
      .brandweer-entry {
        font-size: 0.75em;
        padding: 4px;
        margin: 2px 0;
      }
      .brandweer-time {
        font-size: 0.7em;
      }
    }
  </style>
</head>
<body>
  <div class="container unknown" id="mainContainer">
    <div class="lock-icon-container">
      <span id="lockIcon"></span>
      <div id="lockStatusText" class="status-text">Loading status...</div>
    </div>
    <div class="loading" id="loadingIndicator">
      <span class="material-icons">refresh</span>
      Please wait, fetching lock status...
    </div>
    <button class="btn toggle-btn" id="toggleLockBtn" onclick="toggleLock()" disabled>
      <span class="material-icons">lock</span>
      Toggle Lock
    </button>
    <button class="btn" id="btn10s" onclick="unlockForSeconds(10)" disabled>
      <span class="material-icons">lock_open</span>
      Unlock for 10 seconds
    </button>
    <button class="btn" id="btn30min" onclick="unlockForSeconds(1800)" disabled>
      <span class="material-icons">schedule</span>
      Unlock for 30 minutes
    </button>
    <button class="btn" id="btnSunset" onclick="unlockUntilSunset()" disabled>
      <span class="material-icons">nightlight_round</span>
      Unlock until sunset
    </button>
    <div class="timer" id="timerDisplay"></div>
    <button class="btn" id="clearTimerBtn" onclick="clearTimerState()" style="display: none; background: #ff9800; margin-top: 10px;">
      <span class="material-icons">cleaning_services</span>
      Clear Timer State (Debug)
    </button>

    <!-- Debug buttons for time simulation -->
    <div id="debugButtons" style="display: none; margin-top: 10px; width: 100%;">
      <button class="btn" onclick="simulateTimeChange(-2)" style="background: #2196F3;">
        <span class="material-icons">schedule</span>
        Simulate 2 hours ago
      </button>
      <button class="btn" onclick="simulateTimeChange(2)" style="background: #2196F3;">
        <span class="material-icons">schedule</span>
        Simulate 2 hours later
      </button>
      <button class="btn" onclick="simulateTimeChange(12)" style="background: #2196F3;">
        <span class="material-icons">schedule</span>
        Simulate 12 hours later
      </button>
    </div>

    <div class="info-bar">
      <div class="info-item">
        <span class="material-icons">schedule</span>
        <span id="currentTime">--:--</span>
      </div>
      <div class="info-item">
        <span class="material-icons">calendar_today</span>
        <span id="currentDate">--</span>
      </div>
      <div class="info-item">
        <span class="material-icons">wb_sunny</span>
        <span id="weatherInfo">--</span>
      </div>
      <div class="info-item">
        <span class="material-icons">nightlight_round</span>
        <span id="sunsetTime">--:--</span>
      </div>
    </div>
    <div id="brandweerNotifications" style="width: 100%; margin-top: 8px;">
      <div id="brandweerStatus" class="status">Brandweer Status</div>
    </div>
    <div id="brandweerTimestamp">
      <span class="material-icons">update</span>
      --
    </div>
    <div class="notification-item">
      <span class="material-icons">notifications_active</span>
      <span id="brandweerInfo">--</span>
    </div>
    <!-- Add garbage container info -->
    <div id="garbageInfo" class="notification-item" style="display: none;">
      <span class="material-icons">delete</span>
      <span id="garbageContainerInfo">--</span>
    </div>
    <!-- Add version number -->
    <div class="version-info" style="text-align: center; margin-top: 10px; font-size: 0.8em; color: #888; opacity: 0.5;">
      <span class="material-icons" style="font-size: 0.9em; vertical-align: middle;">info</span>
      <span id="versionNumber">v2.0.0</span>
      <span id="versionStatus" style="font-size: 0.9em; margin-left: 5px; color: #ff9800;">(YAML update required)</span>
    </div>
  </div>

  <!-- Load configuration first -->
  <script>
    // Configuration object
    const config = {
        HA_TOKEN: '',
        HA_URL: window.location.origin.replace('http://', 'https://'),
        VERSION: '2.0.0',
        timezone: 'Europe/Amsterdam',
        codeLength: 6,
        maxAttempts: 3,
        lockoutDuration: 300,
        codeExpiry: 86400,
        tasmotaSwitch: 'switch.tasmota',
        simulationMode: true,
        stateEntities: {
            dailyCode: "input_text.lockcontrol_daily_code",
            dailyCodeExpiry: "input_datetime.lockcontrol_daily_code_expiry",
            oneTimeCode: "input_text.lockcontrol_one_time_code",
            oneTimeCodeExpiry: "input_datetime.lockcontrol_one_time_code_expiry",
            version: "input_text.version"
        }
    };

    // Update version number on load
    document.getElementById('versionNumber').textContent = `v${config.VERSION}`;

    // Error handling and user feedback
    function showError(message, duration = 5000) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.textContent = message;
        document.body.appendChild(errorDiv);
        setTimeout(() => errorDiv.remove(), duration);
    }

    function showSuccess(message, duration = 3000) {
        const successDiv = document.createElement('div');
        successDiv.className = 'success-message';
        successDiv.textContent = message;
        document.body.appendChild(successDiv);
        setTimeout(() => successDiv.remove(), duration);
    }

    function showTokenStatus(success, message) {
        const statusElement = document.getElementById('versionStatus');
        if (statusElement) {
            statusElement.textContent = message;
            statusElement.style.color = success ? '#4caf50' : '#f44336';
        }
    }

    // Check if YAML has been updated
    async function checkYamlVersion() {
        try {
            const response = await fetch(`${config.HA_URL}/api/states/${config.stateEntities.version}`, {
                headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
            });
            if (!response.ok) {
                document.getElementById('versionStatus').style.display = 'inline';
                document.querySelector('.version-info').style.opacity = '0.5';
                return;
            }
            const data = await response.json();
            if (data.state === config.VERSION) {
                document.getElementById('versionStatus').style.display = 'none';
                document.querySelector('.version-info').style.opacity = '1';
            } else {
                document.getElementById('versionStatus').style.display = 'inline';
                document.querySelector('.version-info').style.opacity = '0.5';
            }
        } catch (error) {
            console.error('Error checking YAML version:', error);
            document.getElementById('versionStatus').style.display = 'inline';
            document.querySelector('.version-info').style.opacity = '0.5';
        }
    }

    // Load configuration from config file
    async function loadConfig() {
        try {
            console.log('Starting config load...');
            showTokenStatus(false, 'Loading configuration...');

            if (window.mobileLog) {
                mobileLog('Starting config load');
            }

            // Add cache-busting parameter
            const timestamp = new Date().getTime();
            const baseUrl = window.location.origin;
            const configPaths = [
                `${baseUrl}/local/lockcontrol/config.js?t=${timestamp}`,
                `${baseUrl}/local/config.js?t=${timestamp}`,
                `config.js?t=${timestamp}`,
                `../config.js?t=${timestamp}`
            ];

            if (window.mobileLog) {
                mobileLog('Trying config paths', configPaths);
            }

            let configLoaded = false;
            for (const path of configPaths) {
                try {
                    if (window.mobileLog) {
                        mobileLog('Trying path', path);
                    }

                    const response = await fetch(path, {
                        method: 'GET',
                        headers: {
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        },
                        credentials: 'same-origin'
                    });
                    
                    if (response.ok) {
                        const text = await response.text();
                        if (window.mobileLog) {
                            mobileLog('Config loaded successfully', {
                                path: path,
                                contentPreview: text.substring(0, 100) + '...'
                            });
                        }
                        
                        // Try to find token in JavaScript format first
                        let match = text.match(/HA_TOKEN:\s*'([^']+)'/);
                        if (!match) {
                            match = text.match(/HA_TOKEN=([^\s]+)/);
                        }
                        
                        if (match) {
                            config.HA_TOKEN = match[1];
                            console.log('Token found and set from file');
                            
                            // Store token in localStorage as backup
                            try {
                                localStorage.setItem('ha_token', config.HA_TOKEN);
                                console.log('Token stored in localStorage');
                            } catch (e) {
                                console.warn('Could not store token in localStorage:', e);
                            }
                        } else {
                            console.warn('No token found in config file');
                        }

                        // Try to find URL in JavaScript format first
                        let urlMatch = text.match(/HA_URL:\s*'([^']+)'/);
                        if (!urlMatch) {
                            urlMatch = text.match(/HA_URL=([^\s]+)/);
                        }
                        
                        if (urlMatch) {
                            config.HA_URL = urlMatch[1];
                            console.log('URL found and set from file:', config.HA_URL);
                            
                            // Store URL in localStorage as backup
                            try {
                                localStorage.setItem('ha_url', config.HA_URL);
                                console.log('URL stored in localStorage');
                            } catch (e) {
                                console.warn('Could not store URL in localStorage:', e);
                            }
                        } else {
                            console.warn('No URL found in config file');
                        }
                        
                        configLoaded = true;
                        break;
                    } else {
                        console.warn(`Failed to load config from ${path}: ${response.status} ${response.statusText}`);
                    }
                } catch (e) {
                    console.warn(`Error loading config from ${path}:`, e);
                }
            }

            if (!configLoaded) {
                console.log('Failed to load config from any path, trying localStorage');
                // Try to recover from localStorage
                const storedToken = localStorage.getItem('ha_token');
                const storedUrl = localStorage.getItem('ha_url');
                
                if (storedToken) {
                    console.log('Using token from localStorage');
                    config.HA_TOKEN = storedToken;
                }
                if (storedUrl) {
                    console.log('Using URL from localStorage');
                    config.HA_URL = storedUrl;
                }
                
                if (!storedToken || !storedUrl) {
                    throw new Error('Could not load configuration from any source');
                }
            }

            // Verify we have the required values
            if (!config.HA_TOKEN || !config.HA_URL) {
                showTokenStatus(false, 'Missing configuration values');
                throw new Error('Missing required configuration values');
            }

            console.log('Configuration loaded successfully:', {
                url: config.HA_URL,
                hasToken: !!config.HA_TOKEN,
                tokenLength: config.HA_TOKEN.length
            });

            // After successful config load
            showTokenStatus(true, 'Configuration loaded');

        } catch (error) {
            console.error('Error loading config:', error);
            showTokenStatus(false, 'Configuration load failed: ' + error.message);
            showError('Failed to load configuration. Please check your config file and try clearing your browser cache.');
            throw error;
        }
    }

    // Add a function to clear cache and reload
    function clearCacheAndReload() {
        try {
            localStorage.clear();
            sessionStorage.clear();
            window.location.reload(true);
        } catch (e) {
            console.error('Error clearing cache:', e);
            window.location.reload(true);
        }
    }

    // Add cache clear button for mobile devices
    if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        const clearButton = document.createElement('button');
        clearButton.className = 'btn warning';
        clearButton.style.marginTop = '10px';
        clearButton.innerHTML = '<span class="material-icons">cleaning_services</span> Clear Cache & Reload';
        clearButton.onclick = () => {
            showTokenStatus(false, 'Clearing cache...');
            clearCacheAndReload();
        };
        document.querySelector('.container').appendChild(clearButton);
    }

    // Verify authentication
    async function verifyAuth() {
        try {
            const response = await fetch(`${config.HA_URL}/api/`, {
                headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
            });
            if (!response.ok) {
                throw new Error(`Authentication failed: ${response.status}`);
            }
            console.log('Authentication successful');
            return true;
        } catch (error) {
            console.error('Authentication error:', error);
            showError('Authentication failed. Please check your token and URL.');
            return false;
        }
    }

    // Initialize the application
    async function initializeApp() {
        try {
            await loadConfig();
            const isAuthenticated = await verifyAuth();
            if (!isAuthenticated) {
                throw new Error('Authentication failed');
            }
            // Initialize the rest of your application
            getLockState(false);
            setInterval(() => {
                getLockState(true);
                if (currentState !== 'on') {
                    initializeTimer();
                }
            }, 60000);

            updateSunsetTime();
            setInterval(updateSunsetTime, 3600000);
            initializeTimer();
            updateInfoBar();
            setInterval(updateInfoBar, 60000);
            
            // Check YAML version
            checkYamlVersion();
        } catch (error) {
            console.error('Error initializing app:', error);
            showError('Failed to initialize application. Please check your configuration and token.');
        }
    }

    // Start the application
    document.addEventListener('DOMContentLoaded', () => {
        initializeApp();
    });

    let timerInterval = null;
    let unlockEnd = null;
    let currentState = null;
    let controlsLocked = true;
    let nounlocktimer = 1;
    let lockPerformed = false;
    let brandweerHistory = [];

    // Show debug button if URL has debug parameter
    if (window.location.search.includes('debug')) {
      document.getElementById('clearTimerBtn').style.display = 'block';
      document.getElementById('debugButtons').style.display = 'block';
    }

    function clearTimerState() {
      console.log('Clearing timer state...');
      
      // Check if token is available
      if (!config.HA_TOKEN) {
          console.error('No token available');
          alert('Authentication token not available. Please check your configuration.');
          return Promise.reject('No token available');
      }
      
      // Use current year when clearing the timer
      const now = new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const day = String(now.getDate()).padStart(2, '0');
      
      const data = {
        entity_id: 'input_datetime.lock_unlock_end',
        datetime: `${year}-${month}-${day} 00:00:00`
      };
      
      return fetch(`${config.HA_URL}/api/services/input_datetime/set_datetime`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${config.HA_TOKEN}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
      })
      .then(response => {
        if (!response.ok) {
          if (response.status === 401) {
            throw new Error('Authentication failed. Please check your token.');
          }
          throw new Error('Failed to clear Home Assistant timer state: ' + response.status);
        }
        console.log('Home Assistant timer state cleared');
        
        // Clear any running timer
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
        
        // Update display
        updateTimerDisplay(null);
        
        // Show success message
        const timer = document.getElementById('timerDisplay');
        timer.textContent = 'Timer state cleared';
        timer.style.color = '#ff9800';
        setTimeout(() => {
          timer.textContent = 'No timer running';
          timer.className = 'timer unavailable';
        }, 2000);
      })
      .catch(error => {
        console.error('Error clearing timer state:', error);
        alert('Failed to clear timer state: ' + error.message);
      });
    }

    function setControlsEnabled(enabled) {
      document.getElementById('toggleLockBtn').disabled = !enabled;
      document.getElementById('btn10s').disabled = !enabled;
      document.getElementById('btn30min').disabled = !enabled;
      document.getElementById('btnSunset').disabled = !enabled;
    }

    function showLoading(show) {
      document.getElementById('loadingIndicator').style.display = show ? 'block' : 'none';
    }

    function callService(service, data) {
      setControlsEnabled(false);
      showLoading(true);
      
      // Log service call for mobile
      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        console.log('Mobile: Calling service:', service, data);
      }
      
      return fetch(`${config.HA_URL}/api/services/${service.split('.')[0]}/${service.split('.')[1]}`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${config.HA_TOKEN}`,
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'Pragma': 'no-cache'
        },
        body: JSON.stringify(data)
      })
      .then(res => {
        if (!res.ok) {
          throw new Error(`Service call failed: ${res.status}`);
        }
        return res.json();
      })
      .then(() => {
        // After service call, re-fetch state to re-enable controls
        setTimeout(() => getLockState(false), 1000);
      })
      .catch(error => {
        console.error('Service call error:', error);
        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
          showTokenStatus(false, 'Service call failed: ' + error.message);
        }
        setControlsEnabled(true);
        showLoading(false);
      });
    }

    // backgroundPoll: true = background poll, false = user action/initial load
    function getLockState(backgroundPoll = false) {
      if (!backgroundPoll) {
        setControlsEnabled(false);
        showLoading(true);
      }
      
      // Log mobile debug info
      logMobileDebug();
      
      console.log('Fetching lock state from:', config.tasmotaSwitch);
      
      fetch(`${config.HA_URL}/api/states/${config.tasmotaSwitch}`, {
        headers: { 
          'Authorization': `Bearer ${config.HA_TOKEN}`,
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'Pragma': 'no-cache'
        }
      })
      .then(res => {
        if (!res.ok) {
          throw new Error(`Failed to fetch lock state: ${res.status}`);
        }
        return res.json();
      })
      .then(data => {
        console.log('Lock state response:', data);
        currentState = data.state;
        updateLockStatus();
        if (!backgroundPoll) {
          setControlsEnabled(true);
          showLoading(false);
        }
        // Log success for mobile
        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
          console.log('Mobile: Lock state updated successfully:', currentState);
        }
      })
      .catch(error => {
        console.error('Error fetching lock state:', error);
        document.getElementById('lockStatusText').textContent = 'Error fetching status';
        document.getElementById('lockStatusText').className = 'status-text';
        if (!backgroundPoll) {
          setControlsEnabled(false);
          showLoading(true);
        }
        // Show error on mobile
        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
          showTokenStatus(false, 'Failed to fetch lock state: ' + error.message);
          console.error('Mobile: Lock state fetch failed:', error);
        }
      });
    }

    function getStoredTimerState() {
      console.log('Getting stored timer state');
      console.log('Current device timezone:', Intl.DateTimeFormat().resolvedOptions().timeZone);
      console.log('Device ID:', navigator.userAgent); // Log device info
      
      return fetch(`${config.HA_URL}/api/states/input_datetime.lock_unlock_end`, {
        method: 'GET',
        headers: { 
          'Authorization': `Bearer ${config.HA_TOKEN}`,
          'Content-Type': 'application/json'
        }
      })
      .then(res => {
        if (!res.ok) {
          throw new Error('Failed to get timer state: ' + res.status);
        }
        return res.json();
      })
      .then(data => {
        console.log('Raw timer state from Home Assistant:', data);
        console.log('Last updated by:', data.attributes.last_updated_by || 'unknown');
        console.log('Last changed:', data.last_changed);
        if (data && data.state && data.state !== 'unknown') {
          // Parse the datetime string from Home Assistant
          const [datePart, timePart] = data.state.split(' ');
          const [year, month, day] = datePart.split('-').map(Number);
          const [hours, minutes, seconds] = timePart.split(':').map(Number);
          
          // Create a date object with the current year
          const now = new Date();
          const currentYear = now.getFullYear();
          
          // If the year is not current or in the past, clear the state
          if (year !== currentYear) {
            console.log(`Invalid year ${year}, expected ${currentYear}, clearing state`);
            return clearTimerState().then(() => null);
          }
          
          const startTime = new Date(
            year,
            month - 1, // JavaScript months are 0-based
            day,
            hours,
            minutes,
            seconds
          );
          
          // Debug time values
          console.log('Time values:');
          console.log('Start time (raw):', data.state);
          console.log('Start time (parsed):', startTime.toString());
          console.log('Current time:', now.toString());
          
          // Validate the start time
          if (isNaN(startTime.getTime())) {
            console.log('Invalid start time, clearing state');
            return clearTimerState().then(() => null);
          }
          
          // If start time is in the future, something is wrong
          if (startTime > now) {
            console.log('Start time is in the future, clearing invalid state');
            return clearTimerState().then(() => null);
          }
          
          // Calculate time until sunset
          return fetch(`${config.HA_URL}/api/states/sun.sun`, {
            headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
          })
          .then(res => res.json())
          .then(sunData => {
            const sunset = new Date(sunData.attributes.next_setting);
            const timeLeft = sunset.getTime() - now.getTime();
            
            if (timeLeft > 0) {
              return { startTime, endTime: sunset };
            } else {
              console.log('Sunset has passed, clearing state');
              return clearTimerState().then(() => null);
            }
          });
        }
        return null;
      })
      .catch(error => {
        console.error('Failed to get timer state:', error);
        return null;
      });
    }

    function storeTimerState(startTime, duration) {
      console.log('Storing timer state - Start:', startTime, 'Duration:', duration);
      console.log('Current device timezone:', Intl.DateTimeFormat().resolvedOptions().timeZone);
      console.log('Device ID:', navigator.userAgent); // Log device info
      
      // Format the current time in the format Home Assistant expects
      const now = new Date();
      const year = now.getFullYear(); // Use current year
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const day = String(now.getDate()).padStart(2, '0');
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      const seconds = String(now.getSeconds()).padStart(2, '0');
      
      const formattedDate = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
      
      const data = {
        entity_id: 'input_datetime.lock_unlock_end',
        datetime: formattedDate
      };
      console.log('Sending data to Home Assistant:', data);
      
      return fetch(`${config.HA_URL}/api/services/input_datetime/set_datetime`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${config.HA_TOKEN}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
      }).then(response => {
        if (!response.ok) {
          throw new Error('Failed to store timer state: ' + response.status);
        }
        return response.json();
      }).then(data => {
        console.log('Timer state stored successfully in Home Assistant:', data);
        // Verify the stored state
        return getStoredTimerState();
      }).catch(error => {
        console.error('Failed to store timer state:', error);
      });
    }

    function updateLockStatus() {
      const statusText = document.getElementById('lockStatusText');
      const iconSpan = document.getElementById('lockIcon');
      const toggleBtn = document.getElementById('toggleLockBtn');
      const mainContainer = document.getElementById('mainContainer');
      if (currentState === 'on') {
        // When lock is on, clear any active timer
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
        clearTimerState();
        updateTimerDisplay(null);
        
        statusText.textContent = 'Locked';
        iconSpan.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="#388e3c" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" style="width:3.5em;height:3.5em;"><rect x="3" y="11" width="18" height="10" rx="2" fill="#43a047" stroke="#388e3c"/><path d="M7 11V7a5 5 0 0 1 10 0v4" stroke="#388e3c" fill="none"/><circle cx="12" cy="16" r="2" fill="#fff"/></svg>`;
        toggleBtn.textContent = 'Unlock';
        toggleBtn.classList.remove('unlocked');
        mainContainer.className = 'container locked';
        nounlocktimer = 1; // No unlock timer when locked
        lockPerformed = true; // Lock has been performed
      } else if (currentState === 'off') {
        statusText.textContent = 'Unlocked';
        iconSpan.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="#d32f2f" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" style="width:3.5em;height:3.5em;"><rect x="3" y="11" width="18" height="10" rx="2" fill="#e53935" stroke="#d32f2f"/><path d="M7 11V7a5 5 0 0 1 10 0" stroke="#d32f2f" fill="none"/><circle cx="12" cy="16" r="2" fill="#fff"/></svg>`;
        toggleBtn.textContent = 'Lock';
        toggleBtn.classList.add('unlocked');
        mainContainer.className = 'container unlocked';
        nounlocktimer = 0; // Unlock timer active when unlocked
        // Only initialize timer if it was manually unlocked
        if (lockPerformed) {
          initializeTimer();
        }
      } else {
        statusText.textContent = 'Unknown';
        iconSpan.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="#888" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" style="width:3.5em;height:3.5em;"><rect x="3" y="11" width="18" height="10" rx="2" fill="#eee" stroke="#888"/><path d="M7 11V7a5 5 0 0 1 10 0" stroke="#888" fill="none"/><circle cx="12" cy="16" r="2" fill="#888"/></svg>`;
        toggleBtn.textContent = 'Toggle Lock';
        toggleBtn.classList.remove('unlocked');
        mainContainer.className = 'container unknown';
      }
    }

    function toggleLock() {
      if (currentState === 'on') {
        callService('switch.turn_off', { entity_id: config.tasmotaSwitch });
      } else if (currentState === 'off') {
        // When manually locking, clear any active timer
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
        clearTimerState().then(() => {
          callService('switch.turn_on', { entity_id: config.tasmotaSwitch });
        });
      }
    }

    function updateTimerDisplay(timerState) {
      const timer = document.getElementById('timerDisplay');
      if (timerState) {
        const now = new Date();
        const timeLeft = timerState.endTime.getTime() - now.getTime();
        
        // If time has expired or is unreasonable (more than 24 hours), clear the timer
        if (timeLeft <= 0 || timeLeft > 24 * 60 * 60 * 1000) {
          console.log('Timer expired or unreasonable duration, clearing state');
          clearTimerState();
          return;
        }
        
        const hours = Math.floor(timeLeft / (1000 * 60 * 60));
        const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
        
        console.log('Updating timer display:');
        console.log('Current time:', now.toISOString());
        console.log('End time:', timerState.endTime.toISOString());
        console.log('Time left:', timeLeft / 1000, 'seconds');
        
        if (hours > 0) {
          timer.textContent = `Lock will re-engage in ${hours}h ${minutes}m`;
        } else {
          timer.textContent = `Lock will re-engage in ${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        timer.className = 'timer';
      } else {
        timer.textContent = 'No timer running';
        timer.className = 'timer unavailable';
      }
    }

    function unlockForSeconds(seconds) {
      if (!lockPerformed) {
        alert('Please lock the door first before using this option.');
        return;
      }
      callService('switch.turn_off', { entity_id: 'switch.tasmota' });
      const endTime = new Date(Date.now() + seconds * 1000);
      setTimer(endTime);
    }

    // Format time in European format with explicit timezone
    function formatTime(date) {
        return date.toLocaleTimeString('nl-NL', { 
            hour: '2-digit', 
            minute: '2-digit', 
            hour12: false,
            timeZone: config.timezone 
        });
    }

    // Format date and time in European format with explicit timezone
    function formatDateTime(date) {
        return date.toLocaleString('nl-NL', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            hour12: false,
            timeZone: config.timezone
        });
    }

    // Function to simulate time changes for testing
    function simulateTimeChange(hours) {
      const now = new Date();
      now.setHours(now.getHours() + hours);
      console.log('Simulated time:', now);
      
      // Update the info bar with simulated time
      document.getElementById('currentTime').textContent = now.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', hour12: false });
      document.getElementById('currentDate').textContent = `${now.getDate()}-${now.getMonth() + 1}`;
      
      // Re-run the sunset check with simulated time
      checkSunsetStatus(now);
      return now;
    }

    function unlockUntilSunset() {
      console.log('Attempting to unlock until sunset...');
      if (!lockPerformed) {
        console.log('Lock not performed yet - showing alert');
        alert('Please lock the door first before using this option.');
        return;
      }
      
      fetch(`${config.HA_URL}/api/states/sun.sun`, {
        headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
      })
        .then(res => res.json())
        .then(data => {
          const sunset = new Date(data.attributes.next_setting);
          callService('switch.turn_off', { entity_id: 'switch.tasmota' });
          setTimer(sunset);
        })
        .catch(error => {
          console.error('Error fetching sunset time:', error);
          alert('Failed to fetch sunset time. Please try again.');
        });
    }

    function checkSunsetStatus(simulatedTime) {
      console.log('Checking sunset status...');
      fetch(`${config.HA_URL}/api/states/sun.sun`, {
        headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
      })
        .then(res => res.json())
        .then(data => {
          const sunset = new Date(data.attributes.next_setting);
          const sunrise = new Date(data.attributes.next_rising);
          const sunsetBtn = document.getElementById('btnSunset');
          const now = simulatedTime || new Date();
          
          console.log('Time debug:');
          console.log('Current time:', now.toLocaleString());
          console.log('Sunset time:', sunset.toLocaleString());
          console.log('Sunrise time:', sunrise.toLocaleString());
          console.log('Is after sunset?', now >= sunset);
          console.log('Is before sunrise?', now < sunrise);
          
          // If it's after sunset and before next sunrise, button should be disabled
          if (now >= sunset || now < sunrise) {
            console.log('Nighttime detected - disabling button');
            sunsetBtn.style.backgroundColor = '#888';
            sunsetBtn.style.cursor = 'not-allowed';
            sunsetBtn.textContent = 'Not available at night';
            sunsetBtn.disabled = true;
          } 
          // If it's after sunrise and before sunset, button should be enabled
          else {
            console.log('Daytime detected - enabling button');
            sunsetBtn.style.backgroundColor = '';
            sunsetBtn.style.cursor = '';
            sunsetBtn.textContent = `Unlock until ${formatTime(sunset)}`;
            sunsetBtn.disabled = false;
          }
        })
        .catch(error => {
          console.error('Error in checkSunsetStatus:', error);
        });
    }

    // Add a function to update sunset time display periodically
    function updateSunsetTime() {
      fetch(`${config.HA_URL}/api/states/sun.sun`, {
        headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
      })
        .then(res => res.json())
        .then(data => {
          const sunset = new Date(data.attributes.next_setting);
          const sunsetBtn = document.getElementById('btnSunset');
          sunsetBtn.textContent = `Unlock until ${formatTime(sunset)}`;
        })
        .catch(error => {
          console.error('Error updating sunset time:', error);
        });
    }

    // Check for existing timer when page loads
    function initializeTimer() {
      try {
        console.log('Initializing timer...');
        // Only check timer if the lock is currently unlocked
        if (currentState === 'off') {
          getStoredTimerState().then(timerState => {
            console.log('Initial timer check - state:', timerState);

            if (timerState) {
              // Clear any existing interval
              if (timerInterval) clearInterval(timerInterval);

              // Start a new interval for smooth countdown
              timerInterval = setInterval(() => {
                const now = new Date();
                const timeLeft = timerState.endTime.getTime() - now.getTime();
                if (timeLeft <= 0) {
                  callService('switch.turn_on', { entity_id: 'switch.tasmota' });
                  clearInterval(timerInterval);
                  updateTimerDisplay(null);
                  clearTimerState();
                } else {
                  updateTimerDisplay(timerState);
                }
              }, 1000);

              updateTimerDisplay(timerState);
            } else {
              if (timerInterval) clearInterval(timerInterval);
              updateTimerDisplay(null);
            }
          });
        } else {
          // If lock is on, clear any existing timer
          if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
          }
          updateTimerDisplay(null);
          clearTimerState();
        }
      } catch (error) {
        console.error('Error initializing timer:', error);
        getLockState(false);
      }
    }

    // Add these new functions for the info bar
    function updateInfoBar() {
      // Time and date
      const now = new Date();
      document.getElementById('currentTime').textContent = now.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', hour12: false });
      document.getElementById('currentDate').textContent = `${now.getDate()}-${now.getMonth() + 1}`;

      // Weather
      fetch(`${config.HA_URL}/api/states/weather.forecast_home`, { 
        headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` } 
      })
        .then(res => res.json())
        .then(data => {
          if (data && data.state && data.attributes) {
            document.getElementById('weatherInfo').textContent = `${data.state}, ${data.attributes.temperature}°C`;
          }
        });

      // Sunset
      fetch(`${config.HA_URL}/api/states/sun.sun`, {
        headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
      })
        .then(res => res.json())
        .then(data => {
          if (data && data.attributes && data.attributes.next_setting) {
            const sunset = new Date(data.attributes.next_setting);
            document.getElementById('sunsetTime').textContent = sunset.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', hour12: false });
          }
        });

      // Brandweer notification
      fetch(`${config.HA_URL}/api/states/sensor.friesland`, { 
        headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` } 
      })
        .then(res => res.json())
        .then(data => {
          updateBrandweerNotifications(data);
        });

      // Garbage container info
      fetch(`${config.HA_URL}/api/states/sensor.omrin_tomorrow`, { 
        headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` } 
      })
        .then(res => res.json())
        .then(data => {
          const garbageInfo = document.getElementById('garbageInfo');
          const garbageContainerInfo = document.getElementById('garbageContainerInfo');
          
          if (data && data.state && data.state !== 'unknown' && data.state !== 'none') {
            garbageInfo.style.display = 'flex';
            garbageContainerInfo.textContent = `Tomorrow: ${data.state}`;
          } else {
            garbageInfo.style.display = 'none';
          }
        });
    }

    // Update brandweer notifications
    async function updateBrandweerNotifications() {
        try {
            const response = await fetch(`${config.HA_URL}/api/states/sensor.brandweer`, {
                headers: { 'Authorization': `Bearer ${config.HA_TOKEN}` }
            });
            
            if (!response.ok) {
                throw new Error(`Failed to get brandweer state: ${response.status}`);
            }
            
            const data = await response.json();
            const brandweerStatus = document.getElementById('brandweerStatus');
            const brandweerInfo = document.getElementById('brandweerInfo');
            const brandweerTimestamp = document.getElementById('brandweerTimestamp');
            
            if (data.state === 'on') {
                brandweerStatus.textContent = 'Brandweer Active';
                brandweerStatus.className = 'status warning';
                
                // Add to history if it's a new message
                const message = data.attributes.message || 'Brandweer alert';
                const timestamp = new Date().toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
                
                // Check if this is a new message
                if (!brandweerHistory.length || brandweerHistory[0].message !== message) {
                    brandweerHistory.unshift({ message, timestamp });
                    // Keep only last 3 messages
                    if (brandweerHistory.length > 3) {
                        brandweerHistory.pop();
                    }
                }
                
                // Update display
                brandweerInfo.textContent = brandweerHistory[0].message;
                brandweerTimestamp.innerHTML = `<span class="material-icons">update</span> ${brandweerHistory[0].timestamp}`;
                
                // Show history in notifications
                const notificationsContainer = document.getElementById('brandweerNotifications');
                notificationsContainer.innerHTML = `
                    <div id="brandweerStatus" class="status warning">Brandweer Active</div>
                    ${brandweerHistory.map(entry => `
                        <div class="brandweer-entry">
                            <span class="material-icons">warning</span>
                            <div class="brandweer-content">
                                <div>${entry.message}</div>
                                <div class="brandweer-time">${entry.timestamp}</div>
                            </div>
                        </div>
                    `).join('')}
                `;
                
                showError('Brandweer sensor is active!');
            } else {
                brandweerStatus.textContent = 'Brandweer Inactive';
                brandweerStatus.className = 'status success';
                brandweerInfo.textContent = 'No active alerts';
                brandweerTimestamp.innerHTML = `<span class="material-icons">update</span> ${new Date().toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' })}`;
            }
        } catch (error) {
            console.error('Error updating brandweer status:', error);
            showError('Failed to update brandweer status');
        }
    }

    // Initialize with error handling
    async function init() {
        try {
            await loadConfig();
            const isAuthenticated = await verifyAuth();
            if (!isAuthenticated) {
                throw new Error('Authentication failed');
            }
            
            await loadSavedState();
            updateAttemptsDisplay();
            setInterval(() => updateDailyCode(), 60000); // Check daily code expiry every minute
            setInterval(checkLockout, 1000); // Check lockout every second
            setInterval(updateBrandweerNotifications, 30000); // Check brandweer status every 30 seconds
            if (config.simulationMode) {
                addKeypadSimulation();
            }
            
            // Check YAML version
            checkYamlVersion();
            
            showSuccess('System initialized successfully');
        } catch (error) {
            console.error('Error initializing system:', error);
            showError('Failed to initialize system. Please refresh the page.');
        }
    }

    // Add mobile-specific initialization
    function initMobile() {
        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
            console.log('Initializing mobile device...');
            
            // Create debug panel
            const debugPanel = document.createElement('div');
            debugPanel.id = 'mobileDebugPanel';
            debugPanel.style.cssText = `
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: rgba(0,0,0,0.8);
                color: #fff;
                padding: 10px;
                font-family: monospace;
                font-size: 12px;
                z-index: 9999;
                max-height: 200px;
                overflow-y: auto;
                display: none;
            `;
            document.body.appendChild(debugPanel);

            // Add debug toggle button
            const debugButton = document.createElement('button');
            debugButton.innerHTML = '🔍 Debug';
            debugButton.style.cssText = `
                position: fixed;
                bottom: 10px;
                right: 10px;
                z-index: 10000;
                padding: 8px 16px;
                background: #2196F3;
                color: white;
                border: none;
                border-radius: 4px;
                font-size: 14px;
            `;
            debugButton.onclick = () => {
                const panel = document.getElementById('mobileDebugPanel');
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            };
            document.body.appendChild(debugButton);

            // Function to log to debug panel
            window.mobileLog = function(message, data) {
                const panel = document.getElementById('mobileDebugPanel');
                const entry = document.createElement('div');
                entry.style.borderBottom = '1px solid rgba(255,255,255,0.1)';
                entry.style.padding = '4px 0';
                
                const time = new Date().toLocaleTimeString();
                let content = `[${time}] ${message}`;
                
                if (data) {
                    try {
                        content += '\n' + JSON.stringify(data, null, 2);
                    } catch (e) {
                        content += '\n' + String(data);
                    }
                }
                
                entry.textContent = content;
                panel.insertBefore(entry, panel.firstChild);
                console.log(message, data);
            };

            // Log initial mobile info
            mobileLog('Mobile Device Info', {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                screenSize: `${window.innerWidth}x${window.innerHeight}`,
                baseUrl: window.location.origin,
                path: window.location.pathname,
                fullUrl: window.location.href
            });

            // Add mobile-specific meta tags
            const meta = document.createElement('meta');
            meta.name = 'apple-mobile-web-app-capable';
            meta.content = 'yes';
            document.head.appendChild(meta);

            // Prevent pull-to-refresh
            document.body.style.overscrollBehavior = 'none';

            // Add mobile-specific event listeners
            document.addEventListener('touchstart', function(e) {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });

            // Add mobile-specific styles
            const style = document.createElement('style');
            style.textContent = `
                @media (max-width: 600px) {
                    .container {
                        padding: 8px 15px 3px 15px;
                        min-height: calc(100vh - 40px);
                        height: calc(100vh - 40px);
                        overflow: hidden;
                    }
                    .btn {
                        padding: 12px 0;
                        margin: 8px 0;
                    }
                    .status-text {
                        font-size: 1em;
                        margin: 8px 0;
                    }
                }
            `;
            document.head.appendChild(style);

            // Add error handler
            window.onerror = function(msg, url, line, col, error) {
                mobileLog('Error', {
                    message: msg,
                    url: url,
                    line: line,
                    column: col,
                    error: error ? error.stack : 'No stack trace'
                });
                return false;
            };

            // Add unhandled promise rejection handler
            window.onunhandledrejection = function(event) {
                mobileLog('Unhandled Promise Rejection', {
                    reason: event.reason
                });
            };

            mobileLog('Mobile initialization complete');
        }
    }

    // Initialize mobile-specific features
    initMobile();

    // Add mobile-specific debugging
    function logMobileDebug() {
      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        console.log('Mobile Debug Info:', {
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          config: {
            tasmotaSwitch: config.tasmotaSwitch,
            haUrl: config.HA_URL,
            hasToken: !!config.HA_TOKEN,
            tokenLength: config.HA_TOKEN?.length
          },
          currentState: currentState,
          controlsLocked: controlsLocked
        });
      }
    }
  </script>
</body>
</html>